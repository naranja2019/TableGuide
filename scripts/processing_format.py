import random
import json
import sys
import re
from utils.request_gpt import request_gpt_chat, request_gpt_embedding
from utils.processing import sample_table_rows


def get_row_template(table, prompt):
    """
    Generates a row template based on a sampled table and prompt.
    
    Args:
        table: The input table containing data.
        prompt: The prompt to generate the row template.

    Returns:
        A row template generated by the GPT model.
    """
    header, sampled_rows = sample_table_rows(table)
    markdown_header = "| " + " | ".join(header) + " |\n"
    markdown_rows = ""
    for row in sampled_rows:
        markdown_rows += "| " + " | ".join(row) + " |\n"

    prompt = prompt.format(header=markdown_header, sampled_rows=markdown_rows)

    max_attempts = 10
    for attempt in range(max_attempts):
        row_template = request_gpt_chat(prompt=prompt)
        
        if validate_row_template(row_template, header):
            return row_template
        else:
            print(f"Attempt {attempt + 1}: Generated row template does not match the expected format, retrying...")
    raise ValueError("Failed to generate row template in the expected format after multiple attempts.")


def get_col_template(table, prompt):
    """
    Generates a column template based on a sampled table and prompt.
    
    Args:
        table: The input table containing data.
        prompt: The prompt to generate the column template.

    Returns:
        A column template generated by the GPT model.
    """
    header, sampled_rows = sample_table_rows(table)
    markdown_header = "| " + " | ".join(header) + " |\n"
    markdown_rows = ""
    for row in sampled_rows:
        markdown_rows += "| " + " | ".join(row) + " |\n"

    prompt = prompt.format(header=markdown_header, sampled_rows=markdown_rows)

    max_attempts = 10
    for attempt in range(max_attempts):
        col_template = request_gpt_chat(prompt=prompt)
        
        if validate_col_template(col_template, header):
            return col_template
        else:
            print(f"Attempt {attempt + 1}: Generated template does not match the expected format, retrying...")
    raise ValueError("Failed to generate column template in the expected format after multiple attempts.")


def validate_col_template(col_template, header):
    """
    Validates whether the generated column descriptions follow the required format.

    Args:
        col_template: The generated template for column descriptions.
        header: The table header containing column names.

    Returns:
        True if each column description is in the specified format and matches the header; False otherwise.
    """
    pattern = r"^Col\d+ ## .+: .+(\n|$)"
    col_template_lines = col_template.strip().splitlines()

    if len(col_template_lines) == len(header) and all(re.match(pattern, line) for line in col_template_lines):
        return True
    return False


def validate_row_template(row_template, header):
    """
    Validates whether the row description template follows the specified format.

    Args:
        row_template: The generated template for row descriptions.
        header: The table header containing column names.

    Returns:
        True if all placeholders in the template match the column names in the header; False otherwise.
    """
    placeholders = re.findall(r"\{(.*?)\}", row_template)
    return all(placeholder in header for placeholder in placeholders)


def get_row_description(table, row_prompt):
    """
    Generates natural language descriptions for each row of the table.

    Args:
        table: The input table containing data.
        row_prompt: The prompt used to generate row templates.

    Returns:
        A list of natural language descriptions for each row in the table.
    """
    row_template = get_row_template(table, row_prompt)
    header, *rows = table

    descriptions = []
    for row in rows:
        row_data = dict(zip(header, row))
        description = row_template.format(**row_data)
        descriptions.append(description)

    return descriptions



def get_col_description(table, col_prompt):
    """
    Generates natural language descriptions for each column in the table.

    Args:
        table: The input table containing data.
        col_prompt: The prompt used to generate column templates.

    Returns:
        A list of natural language descriptions for each column in the table.
    """
    col_template = get_col_template(table, col_prompt)
    column_descriptions = col_template.split('\n')

    header, *rows = table

    column_texts = []
    for i, col_name in enumerate(header):
        description = column_descriptions[i] if i < len(column_descriptions) else "No description available."
        column_texts.append(description)

    return column_texts


def get_row_flattened(table):
    """
    Flattens each row of the table into a single string.

    Args:
        table: The input table containing data.

    Returns:
        A list of strings where each string is a flattened version of a row in the table.
    """
    flattened_rows = []
    for row in table[1:]:
        flattened_row = ''.join(row)
        flattened_rows.append(flattened_row)
    
    return flattened_rows



# if __name__ == "__main__":

#     with open("dataset/4096_test.jsonl", 'r') as f:
#         data = f.readlines()
#     for d in data:
#         item = json.loads(d)
#         table = item["table_text"]
   
#     with open("prompt/get_row_template.md", "r") as f:
#         row_prompt = f.read()

#     with open("prompt/get_col_template.md", "r") as f:
#         col_prompt = f.read()

#     # row_template = get_row_template(table, row_prompt)
#     # col_template = get_col_template(table, col_prompt)

#     # print(row_template)
#     # print(col_template)

#     row_descriptions = get_row_description(table, row_prompt)
#     col_descriptions = get_col_description(table, col_prompt)

#     print(row_descriptions)
#     print(col_descriptions)

#     embedding = request_gpt_embedding(row_descriptions[0])
#     print(embedding)
#     print(len(embedding))